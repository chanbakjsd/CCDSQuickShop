// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package shop

import (
	"context"
	"database/sql"
)

const associateOrder = `-- name: AssociateOrder :exec
UPDATE
	orders
SET
	payment_reference = ?
WHERE
	order_id = ?
`

type AssociateOrderParams struct {
	PaymentReference sql.NullString
	OrderID          string
}

func (q *Queries) AssociateOrder(ctx context.Context, arg AssociateOrderParams) error {
	_, err := q.db.ExecContext(ctx, associateOrder, arg.PaymentReference, arg.OrderID)
	return err
}

const authAdminUser = `-- name: AuthAdminUser :one
SELECT
	email
FROM
	admin_users
WHERE
	email = ?
`

func (q *Queries) AuthAdminUser(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRowContext(ctx, authAdminUser, email)
	err := row.Scan(&email)
	return email, err
}

const completeCheckout = `-- name: CompleteCheckout :one
UPDATE
	orders
SET
	payment_time = COALESCE(payment_time, ?),
	coupon_id = (
		SELECT coupon_id FROM (
			SELECT
				coupon_id
			FROM
				coupons
			WHERE
				stripe_id = ?
			UNION ALL
			SELECT NULL
		) x
		LIMIT 1
	)
WHERE
	orders.payment_reference = ?
RETURNING order_id
`

type CompleteCheckoutParams struct {
	PaymentTime      sql.NullTime
	CouponStripeID   string
	PaymentReference sql.NullString
}

func (q *Queries) CompleteCheckout(ctx context.Context, arg CompleteCheckoutParams) (string, error) {
	row := q.db.QueryRowContext(ctx, completeCheckout, arg.PaymentTime, arg.CouponStripeID, arg.PaymentReference)
	var order_id string
	err := row.Scan(&order_id)
	return order_id, err
}

const countAdminUsers = `-- name: CountAdminUsers :one
SELECT
	COUNT(*)
FROM
	admin_users
`

func (q *Queries) CountAdminUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const couponByID = `-- name: CouponByID :one
SELECT
	coupon_id, coupon_code, stripe_id, min_purchase_quantity, discount_percentage, enabled, public, redemption_limit
FROM
	coupons
WHERE
	coupon_id = ?
`

func (q *Queries) CouponByID(ctx context.Context, couponID int64) (Coupon, error) {
	row := q.db.QueryRowContext(ctx, couponByID, couponID)
	var i Coupon
	err := row.Scan(
		&i.CouponID,
		&i.CouponCode,
		&i.StripeID,
		&i.MinPurchaseQuantity,
		&i.DiscountPercentage,
		&i.Enabled,
		&i.Public,
		&i.RedemptionLimit,
	)
	return i, err
}

const couponEnabledByCode = `-- name: CouponEnabledByCode :one
SELECT
	coupon_id, coupon_code, stripe_id, min_purchase_quantity, discount_percentage, enabled, public, redemption_limit
FROM
	coupons
WHERE
	coupon_code = ?
	AND enabled = TRUE
`

func (q *Queries) CouponEnabledByCode(ctx context.Context, couponCode string) (Coupon, error) {
	row := q.db.QueryRowContext(ctx, couponEnabledByCode, couponCode)
	var i Coupon
	err := row.Scan(
		&i.CouponID,
		&i.CouponCode,
		&i.StripeID,
		&i.MinPurchaseQuantity,
		&i.DiscountPercentage,
		&i.Enabled,
		&i.Public,
		&i.RedemptionLimit,
	)
	return i, err
}

const createAdminUser = `-- name: CreateAdminUser :exec
INSERT INTO admin_users (
	email
) VALUES (
	?
) ON CONFLICT DO NOTHING
`

func (q *Queries) CreateAdminUser(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, createAdminUser, email)
	return err
}

const createCoupon = `-- name: CreateCoupon :one
INSERT INTO coupons (
	coupon_code, min_purchase_quantity, discount_percentage, enabled
) VALUES (
	?, ?, ?, ?
) RETURNING coupon_id
`

type CreateCouponParams struct {
	CouponCode          string
	MinPurchaseQuantity sql.NullInt64
	DiscountPercentage  int64
	Enabled             bool
}

func (q *Queries) CreateCoupon(ctx context.Context, arg CreateCouponParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createCoupon,
		arg.CouponCode,
		arg.MinPurchaseQuantity,
		arg.DiscountPercentage,
		arg.Enabled,
	)
	var coupon_id int64
	err := row.Scan(&coupon_id)
	return coupon_id, err
}

const createOrder = `-- name: CreateOrder :exec
INSERT INTO orders (
	order_id, name, matric_number, email, payment_reference, payment_time, collection_time, cancelled, coupon_id
) VALUES (
	?, ?, ?, ?, NULL, NULL, NULL, FALSE, ?
)
`

type CreateOrderParams struct {
	OrderID      string
	Name         string
	MatricNumber string
	Email        string
	CouponID     sql.NullInt64
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.ExecContext(ctx, createOrder,
		arg.OrderID,
		arg.Name,
		arg.MatricNumber,
		arg.Email,
		arg.CouponID,
	)
	return err
}

const createOrderItem = `-- name: CreateOrderItem :exec
INSERT INTO order_items (
	order_id, product_id, product_name, unit_price, amount, image_url, variant
) VALUES (
	?, ?, ?, ?, ?, ?, ?
)
`

type CreateOrderItemParams struct {
	OrderID     string
	ProductID   string
	ProductName string
	UnitPrice   int64
	Amount      int64
	ImageUrl    string
	Variant     string
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) error {
	_, err := q.db.ExecContext(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.ProductName,
		arg.UnitPrice,
		arg.Amount,
		arg.ImageUrl,
		arg.Variant,
	)
	return err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
	name, base_price, default_image_url, variants, variant_image_urls, enabled
) VALUES (
	?, ?, ?, ?, ?, ?
) RETURNING product_id
`

type CreateProductParams struct {
	Name             string
	BasePrice        int64
	DefaultImageUrl  string
	Variants         string
	VariantImageUrls string
	Enabled          bool
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.BasePrice,
		arg.DefaultImageUrl,
		arg.Variants,
		arg.VariantImageUrls,
		arg.Enabled,
	)
	var product_id int64
	err := row.Scan(&product_id)
	return product_id, err
}

const deleteAdminUser = `-- name: DeleteAdminUser :exec
DELETE FROM
	admin_users
WHERE
	email = ?
`

func (q *Queries) DeleteAdminUser(ctx context.Context, email string) error {
	_, err := q.db.ExecContext(ctx, deleteAdminUser, email)
	return err
}

const expireCheckout = `-- name: ExpireCheckout :one
UPDATE
	orders
SET
	cancelled = TRUE
WHERE
	payment_reference = ?
RETURNING order_id
`

func (q *Queries) ExpireCheckout(ctx context.Context, paymentReference sql.NullString) (string, error) {
	row := q.db.QueryRowContext(ctx, expireCheckout, paymentReference)
	var order_id string
	err := row.Scan(&order_id)
	return order_id, err
}

const listAdminUsers = `-- name: ListAdminUsers :many
SELECT
	email
FROM
	admin_users
`

func (q *Queries) ListAdminUsers(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAdminUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT
	order_id, product_id, product_name, unit_price, amount, image_url, variant
FROM
	order_items
WHERE
	order_id = ?
`

func (q *Queries) ListOrderItems(ctx context.Context, orderID string) ([]OrderItem, error) {
	rows, err := q.db.QueryContext(ctx, listOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.OrderID,
			&i.ProductID,
			&i.ProductName,
			&i.UnitPrice,
			&i.Amount,
			&i.ImageUrl,
			&i.Variant,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT
	product_id, name, base_price, default_image_url, variants, variant_image_urls, enabled
FROM
	products
WHERE
	enabled = TRUE
	OR CAST(?1 AS BOOLEAN)
`

func (q *Queries) ListProducts(ctx context.Context, includeDisabled bool) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProducts, includeDisabled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.BasePrice,
			&i.DefaultImageUrl,
			&i.Variants,
			&i.VariantImageUrls,
			&i.Enabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicCoupons = `-- name: ListPublicCoupons :many
SELECT
	coupon_id, coupon_code, stripe_id, min_purchase_quantity, discount_percentage, enabled, public, redemption_limit
FROM
	coupons
WHERE
	enabled = TRUE
	AND public = TRUE
`

func (q *Queries) ListPublicCoupons(ctx context.Context) ([]Coupon, error) {
	rows, err := q.db.QueryContext(ctx, listPublicCoupons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coupon
	for rows.Next() {
		var i Coupon
		if err := rows.Scan(
			&i.CouponID,
			&i.CouponCode,
			&i.StripeID,
			&i.MinPurchaseQuantity,
			&i.DiscountPercentage,
			&i.Enabled,
			&i.Public,
			&i.RedemptionLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lookupOrder = `-- name: LookupOrder :many
SELECT
	id, order_id, name, matric_number, email, payment_reference, payment_time, collection_time, cancelled, coupon_id
FROM
	orders
WHERE
	(
		order_id = ?1 COLLATE NOCASE
		OR matric_number = ?1 COLLATE NOCASE
		OR payment_reference = ?1 COLLATE NOCASE
		OR email = ?1 COLLATE NOCASE
		OR email = ?1 || '@e.ntu.edu.sg' COLLATE NOCASE
	)
	AND
	(
		CAST(?2 AS BOOLEAN)
		OR order_id = ?1 COLLATE NOCASE -- Always allow lookup via order ID even if it's cancelled.
		OR cancelled = FALSE
	)
`

type LookupOrderParams struct {
	ID               string
	IncludeCancelled bool
}

func (q *Queries) LookupOrder(ctx context.Context, arg LookupOrderParams) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, lookupOrder, arg.ID, arg.IncludeCancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.Name,
			&i.MatricNumber,
			&i.Email,
			&i.PaymentReference,
			&i.PaymentTime,
			&i.CollectionTime,
			&i.Cancelled,
			&i.CouponID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCouponEnabled = `-- name: SetCouponEnabled :exec
UPDATE
	coupons
SET
	enabled = ?
WHERE
	coupon_id = ?
`

type SetCouponEnabledParams struct {
	Enabled  bool
	CouponID int64
}

func (q *Queries) SetCouponEnabled(ctx context.Context, arg SetCouponEnabledParams) error {
	_, err := q.db.ExecContext(ctx, setCouponEnabled, arg.Enabled, arg.CouponID)
	return err
}

const setProductEnabled = `-- name: SetProductEnabled :exec
UPDATE
	products
SET
	enabled = ?
WHERE
	product_id = ?
`

type SetProductEnabledParams struct {
	Enabled   bool
	ProductID int64
}

func (q *Queries) SetProductEnabled(ctx context.Context, arg SetProductEnabledParams) error {
	_, err := q.db.ExecContext(ctx, setProductEnabled, arg.Enabled, arg.ProductID)
	return err
}

const updateCancelled = `-- name: UpdateCancelled :one
UPDATE
	orders
SET
	cancelled = ?
WHERE
	order_id = ?
	AND cancelled = FALSE
RETURNING
	payment_reference
`

type UpdateCancelledParams struct {
	Cancelled bool
	OrderID   string
}

func (q *Queries) UpdateCancelled(ctx context.Context, arg UpdateCancelledParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, updateCancelled, arg.Cancelled, arg.OrderID)
	var payment_reference sql.NullString
	err := row.Scan(&payment_reference)
	return payment_reference, err
}

const updateCollectionTime = `-- name: UpdateCollectionTime :exec
UPDATE
	orders
SET
	collection_time = COALESCE(collection_time, ?)
WHERE
	order_id = ?
`

type UpdateCollectionTimeParams struct {
	CollectionTime sql.NullTime
	OrderID        string
}

func (q *Queries) UpdateCollectionTime(ctx context.Context, arg UpdateCollectionTimeParams) error {
	_, err := q.db.ExecContext(ctx, updateCollectionTime, arg.CollectionTime, arg.OrderID)
	return err
}

const updateCoupon = `-- name: UpdateCoupon :exec
UPDATE
	coupons
SET
	coupon_code = ?,
	min_purchase_quantity = ?,
	discount_percentage = ?,
	enabled = ?,
	public = ?
WHERE
	coupon_id = ?
`

type UpdateCouponParams struct {
	CouponCode          string
	MinPurchaseQuantity sql.NullInt64
	DiscountPercentage  int64
	Enabled             bool
	Public              bool
	CouponID            int64
}

func (q *Queries) UpdateCoupon(ctx context.Context, arg UpdateCouponParams) error {
	_, err := q.db.ExecContext(ctx, updateCoupon,
		arg.CouponCode,
		arg.MinPurchaseQuantity,
		arg.DiscountPercentage,
		arg.Enabled,
		arg.Public,
		arg.CouponID,
	)
	return err
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE
	products
SET
	name = ?,
	base_price = ?,
	default_image_url = ?,
	variants = ?,
	variant_image_urls = ?,
	enabled = ?
WHERE
	product_id = ?
`

type UpdateProductParams struct {
	Name             string
	BasePrice        int64
	DefaultImageUrl  string
	Variants         string
	VariantImageUrls string
	Enabled          bool
	ProductID        int64
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.ExecContext(ctx, updateProduct,
		arg.Name,
		arg.BasePrice,
		arg.DefaultImageUrl,
		arg.Variants,
		arg.VariantImageUrls,
		arg.Enabled,
		arg.ProductID,
	)
	return err
}
